{% load static %}

<!-- Mapbox GL Draw CSS -->
<link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.css" type="text/css">

<!-- Mapbox Geocoder CSS -->
<link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.css" type="text/css">

<!-- Map Container -->
<div id="climate-hazard-map" style="width: 100%; height: 600px; position: relative;">
  <!-- Drawing Mode Toggle Button -->
  <div id="draw-polygon-controls" style="position: absolute; top: 10px; left: 10px; z-index: 1000;">
    <button id="toggle-draw-mode" class="btn btn-warning btn-sm shadow" onclick="toggleDrawMode()">
      <i class="fas fa-draw-polygon"></i> Draw Polygon Asset
    </button>
    <button id="save-boundary-btn" class="btn btn-success btn-sm shadow ms-2" onclick="saveBoundaryAsAsset()" style="display: none;">
      <i class="fas fa-save"></i> Save City Boundary
    </button>
    <button id="export-shapefile-btn" class="btn btn-primary btn-sm shadow ms-2" onclick="exportShapefile()">
      <i class="fas fa-download"></i> Export Boundaries
    </button>
  </div>

  <!-- Drawing Instructions (shown during draw mode) -->
  <div id="draw-instructions" style="position: absolute; top: 50px; left: 10px; z-index: 1000; display: none; background: rgba(255, 255, 255, 0.95); padding: 10px 15px; border-radius: 5px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);">
    <h6 class="mb-2" style="font-size: 14px; font-weight: bold;">Drawing Polygon:</h6>
    <ul class="mb-0" style="font-size: 12px; padding-left: 20px; margin: 0;">
      <li>Click on map to add points</li>
      <li>Click on first point to close polygon</li>
      <li>Or press <kbd>Enter</kbd> key to finish</li>
    </ul>
  </div>
</div>

<!-- Sidebar (initially hidden off-canvas) -->
<style>
  /* Sidebar styling */
  #sidebar {
    position: fixed;
    top: 0;
    right: -400px;  /* hide off-canvas initially */
    width: 400px;
    height: 100%;
    background: #fff;
    box-shadow: -2px 0 5px rgba(0,0,0,0.3);
    overflow-y: auto;
    transition: right 0.3s ease;
    z-index: 10000;
    padding: 20px;
  }
  #sidebar.visible {
    right: 0;
  }
  #sidebar .close-btn {
    background: #f44336;
    color: #fff;
    border: none;
    padding: 5px 10px;
    cursor: pointer;
    float: right;
  }
  .add-facility-panel {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(255,255,255,0.9);
    padding: 10px;
    border-radius: 5px;
    z-index: 1000;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    display: none;
  }
  /* Custom styling for the hover popup */
  .facility-hover-popup {
    font-family: 'Arial', sans-serif;
  }
  .facility-hover-popup .mapboxgl-popup-content {
    padding: 8px 10px;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border-radius: 4px;
    font-size: 14px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    pointer-events: none;
  }
  .facility-hover-popup .mapboxgl-popup-tip {
    border-top-color: rgba(0, 0, 0, 0.7);
    border-bottom-color: rgba(0, 0, 0, 0.7);
  }
</style>

<div id="sidebar">
  <button class="close-btn" onclick="closeSidebar()">Close</button>
  <div id="sidebar-content"></div>
</div>

<!-- Add Facility Panel (appears when map is clicked) -->
<div id="add-facility-panel" class="add-facility-panel">
  <h5>Add New Facility</h5>
  <div class="mb-3">
    <label for="facility-name" class="form-label">Facility Name</label>
    <input type="text" class="form-control" id="facility-name" placeholder="Enter facility name">
  </div>
  <div class="mb-3">
    <label class="form-label">Coordinates</label>
    <p id="click-coordinates" class="mb-1">Lat: 0, Lng: 0</p>
  </div>
  <div class="d-flex justify-content-end">
    <button class="btn btn-secondary me-2" onclick="cancelAddFacility()">Cancel</button>
    <button class="btn btn-primary" onclick="confirmAddFacility()">Add Facility</button>
  </div>
</div>

<!-- Polygon Asset Modal -->
<div class="modal fade" id="polygonAssetModal" tabindex="-1" aria-labelledby="polygonAssetModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="polygonAssetModalLabel">Add Polygon Asset</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="polygon-asset-form">
          <div class="mb-3">
            <label for="polygon-asset-name" class="form-label">Asset Name <span class="text-danger">*</span></label>
            <input type="text" class="form-control" id="polygon-asset-name" placeholder="Enter asset name" required>
            <div class="invalid-feedback">
              Asset name is required.
            </div>
          </div>
          <div class="mb-3">
            <label for="polygon-asset-archetype" class="form-label">Asset Archetype</label>
            <input type="text" class="form-control" id="polygon-asset-archetype" placeholder="Enter archetype (optional)" value="default archetype">
            <small class="form-text text-muted">Default: "default archetype"</small>
          </div>
          <div class="mb-3">
            <label class="form-label">Centroid Coordinates</label>
            <p id="polygon-centroid-coordinates" class="mb-0 text-muted">Lat: 0, Lng: 0</p>
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" onclick="cancelPolygonAsset()">Cancel</button>
        <button type="button" class="btn btn-primary" onclick="confirmPolygonAsset()">Add Asset</button>
      </div>
    </div>
  </div>
</div>

<!-- Grid Spacing Modal -->
<div class="modal fade" id="gridSpacingModal" tabindex="-1" aria-labelledby="gridSpacingModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header bg-primary text-white">
        <h5 class="modal-title" id="gridSpacingModalLabel">
          <i class="fas fa-th"></i> Configure Granular Analysis
        </h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="alert alert-info mb-3">
          <i class="fas fa-info-circle"></i>
          <strong>Granular Analysis Available!</strong>
          <p class="mb-0 mt-2">
            This area is ≥ 6 km². Select a grid spacing to perform detailed point-by-point hazard analysis across the entire polygon.
          </p>
        </div>

        <div class="mb-3">
          <label class="form-label"><strong>Asset Name:</strong></label>
          <p id="grid-asset-name" class="text-muted mb-0">Loading...</p>
        </div>

        <div class="mb-3">
          <label class="form-label"><strong>Polygon Area:</strong></label>
          <p id="grid-polygon-area" class="text-muted mb-0">Calculating...</p>
        </div>

        <div class="mb-3">
          <label for="grid-spacing-select" class="form-label"><strong>Select Grid Spacing:</strong></label>
          <select class="form-select" id="grid-spacing-select" onchange="updateEstimatedPoints()">
            <option value="10">10 meters (Very Fine)</option>
            <option value="50">50 meters (Fine)</option>
            <option value="100" selected>100 meters (Default)</option>
            <option value="500">500 meters (Coarse)</option>
            <option value="1000">1000 meters (Very Coarse)</option>
          </select>
          <small class="form-text text-muted">Finer spacing = more detailed analysis, but longer processing time.</small>
        </div>

        <div class="mb-3">
          <label class="form-label"><strong>Estimated Sample Points:</strong></label>
          <p id="estimated-points" class="text-primary fw-bold mb-0">Calculating...</p>
          <small class="form-text text-muted">Approximate number of points that will be analyzed.</small>
        </div>

        <div class="alert alert-warning mb-0">
          <i class="fas fa-clock"></i> <strong>Processing Time:</strong> <span id="estimated-time">2-5 seconds</span>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" onclick="skipGranularAnalysis()">
          <i class="fas fa-times"></i> Skip Analysis
        </button>
        <button type="button" class="btn btn-primary" onclick="applyGranularAnalysis()">
          <i class="fas fa-check"></i> Apply Grid Analysis
        </button>
      </div>
    </div>
  </div>
</div>

<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.min.js"></script>

<script>

  // Variables to hold map state
  let multiHazardMap;
  let userMarker = null;
  let clickedLngLat = null;
  let draw;
  let isDrawMode = false;
  let drawnPolygonData = null;
  let geocoder;
  let currentCityBoundary = null;
  let cityBoundaryLayerId = null;



  // Create a base blue circle element for markers
  const baseBlueCircle = document.createElement('div');
  baseBlueCircle.style.width = '20px';
  baseBlueCircle.style.height = '20px';
  baseBlueCircle.style.borderRadius = '50%';
  baseBlueCircle.style.border = '2px solid white';
  baseBlueCircle.style.backgroundColor = 'blue';

  function initializeMultiHazardMap() {
    if (multiHazardMap) {
      multiHazardMap.resize();
      return;
    }

  // Initialize Mapbox
  mapboxgl.accessToken = 'pk.eyJ1Ijoiam91bGUyMzMxIiwiYSI6ImNtZWpqcGRlZDA2aTkybXNmY3BhcnJjMzMifQ.l5raW7vd-PNzS1jYsbyC7g';

    multiHazardMap = new mapboxgl.Map({
        container: 'climate-hazard-map',
        center: [121.7740, 12.8797],
        zoom: 4.5,
        style: 'mapbox://styles/mapbox/satellite-v9'
    })
    .addControl(new mapboxgl.NavigationControl())
    .addControl(new mapboxgl.GeolocateControl())
    .addControl(new mapboxgl.ScaleControl())
    .addControl(new mapboxgl.FullscreenControl());

    // Initialize Mapbox Geocoder
    geocoder = new MapboxGeocoder({
      accessToken: mapboxgl.accessToken,
      mapboxgl: mapboxgl,
      marker: false,
      placeholder: 'Search for a city (e.g., Manila)',
      countries: 'ph', // Limit to Philippines, remove this to search globally
    });

    multiHazardMap.addControl(geocoder, 'top-right');

    // Handle geocoder result
    geocoder.on('result', handleGeocoderResult);

    // Initialize Mapbox Draw
    draw = new MapboxDraw({
      displayControlsDefault: false,
      controls: {},
      defaultMode: 'simple_select'
    });
    multiHazardMap.addControl(draw);

    // When map loads, add base layers
    multiHazardMap.on('load', () => {
      // Add the Philippines GeoJSON source
      multiHazardMap.addSource('hazards-source', {
        type: 'geojson',
        data: 'https://raw.githubusercontent.com/macoymejia/geojsonph/master/Country/Country.minimal.json'
      });

      // Draw filled polygons
      multiHazardMap.addLayer({
        id: 'hazards-layer',
        type: 'fill',
        source: 'hazards-source',
        paint: {
          'fill-color': '#888',
          'fill-opacity': 0.5
        }
      });

      // Change cursor on hover
      multiHazardMap.on('mouseenter', 'hazards-layer', () => {
        multiHazardMap.getCanvas().style.cursor = 'pointer';
      });
      multiHazardMap.on('mouseleave', 'hazards-layer', () => {
        multiHazardMap.getCanvas().style.cursor = '';
      });

      // Try to load facility data if it exists in session
      loadFacilityData();
    });

    // Handle polygon drawing completion
    multiHazardMap.on('draw.create', handlePolygonDrawn);
    multiHazardMap.on('draw.update', handlePolygonDrawn);

    // On map click: show add facility panel (only when not in draw mode)
    multiHazardMap.on('click', (e) => {
      // Skip if in draw mode
      if (isDrawMode) return;

      clickedLngLat = [e.lngLat.lng, e.lngLat.lat];

      // Remove previous temporary marker if it exists
      if (userMarker) {
        userMarker.remove();
      }

      // Create and add new temporary marker
      const el = baseBlueCircle.cloneNode(true);
      el.style.opacity = '0.6'; // Make it semi-transparent to indicate it's temporary
      userMarker = new mapboxgl.Marker({ element: el })
        .setLngLat(clickedLngLat)
        .addTo(multiHazardMap);

      // Update coordinates in the add facility panel
      document.getElementById('click-coordinates').textContent =
        `Lat: ${e.lngLat.lat.toFixed(6)}, Lng: ${e.lngLat.lng.toFixed(6)}`;

      // Show the add facility panel
      document.getElementById('add-facility-panel').style.display = 'block';
    });
  }

  // Toggle drawing mode
  function toggleDrawMode() {
    isDrawMode = !isDrawMode;
    const button = document.getElementById('toggle-draw-mode');
    const instructions = document.getElementById('draw-instructions');

    if (isDrawMode) {
      // Enable draw mode
      draw.changeMode('draw_polygon');
      button.classList.remove('btn-warning');
      button.classList.add('btn-danger');
      button.innerHTML = '<i class="fas fa-times"></i> Cancel Drawing';

      // Show drawing instructions
      if (instructions) {
        instructions.style.display = 'block';
      }

      // Hide add facility panel if visible
      document.getElementById('add-facility-panel').style.display = 'none';
      if (userMarker) {
        userMarker.remove();
        userMarker = null;
      }
    } else {
      // Disable draw mode
      draw.changeMode('simple_select');
      button.classList.remove('btn-danger');
      button.classList.add('btn-warning');
      button.innerHTML = '<i class="fas fa-draw-polygon"></i> Draw Polygon Asset';

      // Hide drawing instructions
      if (instructions) {
        instructions.style.display = 'none';
      }

      // Clear any drawn polygons
      draw.deleteAll();
      drawnPolygonData = null;
    }
  }

  // Handle polygon drawn event
  function handlePolygonDrawn(e) {
    // Wait a bit for draw to complete
    setTimeout(() => {
      const data = draw.getAll();
      if (data.features.length === 0) return;

      const polygon = data.features[0];

      // Validate polygon has at least 3 points
      if (!polygon.geometry || !polygon.geometry.coordinates ||
          !polygon.geometry.coordinates[0] ||
          polygon.geometry.coordinates[0].length < 4) {
        console.log('Polygon not complete yet, waiting...');
        return;
      }

      // Calculate centroid using Turf.js
      const centroid = turf.centroid(polygon);
      const [lng, lat] = centroid.geometry.coordinates;

      // Calculate polygon area in km²
      const areaM2 = turf.area(polygon); // Turf returns area in square meters
      const areaKm2 = areaM2 / 1000000;  // Convert to km²

      // Store polygon data
      drawnPolygonData = {
        geometry: polygon.geometry,
        centroid: { lat, lng },
        areaKm2: areaKm2
      };

      // Exit draw mode
      isDrawMode = false;
      draw.changeMode('simple_select');
      const button = document.getElementById('toggle-draw-mode');
      button.classList.remove('btn-danger');
      button.classList.add('btn-warning');
      button.innerHTML = '<i class="fas fa-draw-polygon"></i> Draw Polygon Asset';

      // Hide drawing instructions
      const instructions = document.getElementById('draw-instructions');
      if (instructions) {
        instructions.style.display = 'none';
      }

      // Check if polygon area qualifies for granular analysis (≥ 6 km²)
      if (areaKm2 >= 6) {
        console.log(`Polygon area: ${areaKm2.toFixed(2)} km² - Showing grid spacing modal`);
        // Show grid spacing modal - asset modal will be shown when user clicks "Apply" or "Skip"
        showGridSpacingModal('New Polygon', polygon.geometry, areaKm2, 'draw');
      } else {
        console.log(`Polygon area: ${areaKm2.toFixed(2)} km² - Skipping granular analysis (< 6 km²)`);
        // Show the polygon asset modal directly
        currentPolygonSource = 'draw';
        showPolygonAssetModal(lat, lng);
      }
    }, 100);
  }

  // Functions for sidebar
  function openSidebar(content) {
    document.getElementById('sidebar-content').innerHTML = content;
    document.getElementById('sidebar').classList.add('visible');
  }
  
  function closeSidebar() {
    document.getElementById('sidebar').classList.remove('visible');
  }

  // Cancel adding a facility
  function cancelAddFacility() {
    // Hide the add facility panel
    document.getElementById('add-facility-panel').style.display = 'none';
    
    // Remove the temporary marker
    if (userMarker) {
      userMarker.remove();
      userMarker = null;
    }
    
    // Reset the clicked coordinates
    clickedLngLat = null;
  }

  // Confirm adding a facility
  function confirmAddFacility() {
    if (!clickedLngLat) {
      alert('No location selected. Please click on the map.');
      return;
    }

    // Get the facility name from the input field
    const facilityName = document.getElementById('facility-name').value.trim() ||
      `New Facility at ${clickedLngLat[1].toFixed(4)}, ${clickedLngLat[0].toFixed(4)}`;

    // Create facility data
    const facilityData = {
      name: facilityName,
      lat: clickedLngLat[1],
      lng: clickedLngLat[0]
    };

    // Send to server
    fetch('/climate-hazards-analysis-v2/api/add-facility/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify(facilityData)
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        // Replace temporary marker with permanent one
        if (userMarker) {
          userMarker.remove();
          userMarker = null;
        }

        // Add the new facility marker
        addFacilityMarker({
          Facility: facilityData.name,
          Lat: facilityData.lat,
          Long: facilityData.lng
        });

        // Hide the add facility panel
        document.getElementById('add-facility-panel').style.display = 'none';

        // Reset the form
        document.getElementById('facility-name').value = '';
      } else {
        alert('Error adding facility: ' + data.error);
      }
    })
    .catch(error => {
      console.error('Error:', error);
      alert('Error adding facility');
    });
  }

  // Show polygon asset modal
  function showPolygonAssetModal(lat, lng) {
    // Update coordinates display
    document.getElementById('polygon-centroid-coordinates').textContent =
      `Lat: ${lat.toFixed(6)}, Lng: ${lng.toFixed(6)}`;

    // Reset form
    document.getElementById('polygon-asset-name').value = '';
    document.getElementById('polygon-asset-archetype').value = 'default archetype';
    document.getElementById('polygon-asset-name').classList.remove('is-invalid');

    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('polygonAssetModal'));
    modal.show();
  }

  // Cancel polygon asset
  function cancelPolygonAsset() {
    // Clear data based on source
    if (currentPolygonSource === 'draw') {
      // Clear drawn polygons
      draw.deleteAll();
      drawnPolygonData = null;
    } else if (currentPolygonSource === 'city') {
      // Clear city boundary data
      window.cityPolygonData = null;
      // Keep the orange boundary visible so user can try again
    }

    // Reset source
    currentPolygonSource = null;

    // Hide modal
    const modal = bootstrap.Modal.getInstance(document.getElementById('polygonAssetModal'));
    if (modal) modal.hide();
  }

  // Confirm polygon asset
  function confirmPolygonAsset() {
    const assetName = document.getElementById('polygon-asset-name').value.trim();
    const assetArchetype = document.getElementById('polygon-asset-archetype').value.trim() || 'default archetype';

    // Validate asset name
    if (!assetName) {
      document.getElementById('polygon-asset-name').classList.add('is-invalid');
      return;
    }

    // Get polygon data from the appropriate source
    let polygonData = null;
    if (currentPolygonSource === 'city' && window.cityPolygonData) {
      polygonData = window.cityPolygonData;
    } else if (currentPolygonSource === 'draw' && drawnPolygonData) {
      polygonData = drawnPolygonData;
    }

    if (!polygonData) {
      alert('No polygon data found. Please draw a polygon or search for a city first.');
      return;
    }

    // Create facility data with polygon geometry
    const facilityData = {
      name: assetName,
      archetype: assetArchetype,
      lat: polygonData.centroid.lat,
      lng: polygonData.centroid.lng,
      geometry: polygonData.geometry,
      areaKm2: polygonData.areaKm2,
      gridSpacing: polygonData.gridSpacing || null
    };

    // Send to server
    fetch('/climate-hazards-analysis-v2/api/add-facility/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify(facilityData)
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        // Clear the drawing only if it's from draw source
        if (currentPolygonSource === 'draw') {
          draw.deleteAll();
          drawnPolygonData = null;
        } else if (currentPolygonSource === 'city') {
          // Remove the orange boundary highlight for city boundaries
          removeCityBoundary();
          // Clear the temporary city polygon data
          window.cityPolygonData = null;
        }

        // Add the new facility marker with polygon
        addFacilityMarker({
          Facility: facilityData.name,
          Archetype: facilityData.archetype,
          Lat: facilityData.lat,
          Long: facilityData.lng,
          geometry: facilityData.geometry
        });

        // Hide modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('polygonAssetModal'));
        if (modal) modal.hide();

        // Reset source
        currentPolygonSource = null;
      } else {
        alert('Error adding asset: ' + data.error);
      }
    })
    .catch(error => {
      console.error('Error:', error);
      alert('Error adding asset');
    });
  }

  // Grid Spacing Modal Functions
  let currentPolygonForGrid = null;
  let currentAssetNameForGrid = null;
  let currentPolygonAreaKm2 = 0;
  let currentPolygonSource = null; // 'draw' or 'city'

  function showGridSpacingModal(assetName, polygonGeometry, polygonAreaKm2, source = 'draw') {
    currentAssetNameForGrid = assetName;
    currentPolygonForGrid = polygonGeometry;
    currentPolygonAreaKm2 = polygonAreaKm2;
    currentPolygonSource = source;

    // Update modal content
    document.getElementById('grid-asset-name').textContent = assetName;
    document.getElementById('grid-polygon-area').textContent = polygonAreaKm2.toFixed(2) + ' km²';

    // Calculate initial estimated points
    updateEstimatedPoints();

    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('gridSpacingModal'));
    modal.show();
  }

  function updateEstimatedPoints() {
    const gridSpacing = parseInt(document.getElementById('grid-spacing-select').value);

    // Calculate approximate number of points
    // Formula: area (km²) * 1,000,000 (m² per km²) / (grid_spacing²)
    const areaM2 = currentPolygonAreaKm2 * 1000000;
    const estimatedPoints = Math.floor(areaM2 / (gridSpacing * gridSpacing));

    document.getElementById('estimated-points').textContent =
      estimatedPoints.toLocaleString() + ' points';

    // Update estimated processing time
    let estimatedTime;
    if (estimatedPoints < 500) {
      estimatedTime = '< 1 second';
    } else if (estimatedPoints < 2000) {
      estimatedTime = '1-2 seconds';
    } else if (estimatedPoints < 5000) {
      estimatedTime = '2-5 seconds';
    } else if (estimatedPoints < 10000) {
      estimatedTime = '5-10 seconds';
    } else {
      estimatedTime = '10-20 seconds';
    }

    document.getElementById('estimated-time').textContent = estimatedTime;
  }

  function applyGranularAnalysis() {
    const gridSpacing = parseInt(document.getElementById('grid-spacing-select').value);

    console.log('=== APPLY GRANULAR ANALYSIS ===');
    console.log('Grid spacing:', gridSpacing);
    console.log('Current polygon source:', currentPolygonSource);

    // Store grid spacing based on the polygon source
    if (currentPolygonSource === 'city' && currentCityBoundary) {
      // For city boundaries, we need to create a temporary polygon data structure
      if (!window.cityPolygonData) {
        window.cityPolygonData = {};
      }
      window.cityPolygonData.gridSpacing = gridSpacing;
      window.cityPolygonData.enableGranular = true;
      window.cityPolygonData.geometry = currentCityBoundary.geometry;

      // Calculate centroid
      const centroid = turf.centroid(currentCityBoundary.geojson);
      const [lng, lat] = centroid.geometry.coordinates;
      window.cityPolygonData.centroid = { lat, lng };
      window.cityPolygonData.areaKm2 = currentPolygonAreaKm2;

      console.log('Grid spacing stored in cityPolygonData');
    } else if (currentPolygonSource === 'draw' && drawnPolygonData) {
      drawnPolygonData.gridSpacing = gridSpacing;
      drawnPolygonData.enableGranular = true;
      console.log('Grid spacing stored in drawnPolygonData');
    } else {
      console.error('No polygon data found!');
      alert('Error: No polygon data found. Please try again.');
      return;
    }

    // Remove focus from the button to avoid aria-hidden warning
    document.activeElement.blur();

    // Hide grid spacing modal and wait for it to fully hide
    const gridModal = bootstrap.Modal.getInstance(document.getElementById('gridSpacingModal'));
    if (gridModal) {
      // Listen for the modal hidden event
      const modalElement = document.getElementById('gridSpacingModal');
      modalElement.addEventListener('hidden.bs.modal', function onHidden() {
        // Remove the event listener to avoid duplicate calls
        modalElement.removeEventListener('hidden.bs.modal', onHidden);

        console.log('Grid modal fully hidden, showing asset modal...');

        // Show notification
        showNotification('Grid spacing configured: ' + gridSpacing + 'm. Complete the asset details.', 'success');

        // Show polygon asset modal to continue with naming the asset
        let centroid = null;
        if (currentPolygonSource === 'city' && window.cityPolygonData) {
          centroid = window.cityPolygonData.centroid;
        } else if (currentPolygonSource === 'draw' && drawnPolygonData) {
          centroid = drawnPolygonData.centroid;
        }

        if (centroid) {
          console.log('Showing polygon asset modal with centroid:', centroid);
          showPolygonAssetModal(centroid.lat, centroid.lng);
        } else {
          console.error('No centroid found');
          alert('Error: Could not find polygon centroid. Please try again.');
        }
      }, { once: true });

      // Now hide the modal
      gridModal.hide();
    } else {
      console.error('Could not get grid modal instance');
    }
  }

  function skipGranularAnalysis() {
    console.log('=== SKIP GRANULAR ANALYSIS ===');
    console.log('Current polygon source:', currentPolygonSource);

    // Mark that granular analysis should be skipped based on source
    if (currentPolygonSource === 'city' && currentCityBoundary) {
      // For city boundaries, create a temporary polygon data structure
      if (!window.cityPolygonData) {
        window.cityPolygonData = {};
      }
      window.cityPolygonData.enableGranular = false;
      window.cityPolygonData.gridSpacing = null;
      window.cityPolygonData.geometry = currentCityBoundary.geometry;

      // Calculate centroid
      const centroid = turf.centroid(currentCityBoundary.geojson);
      const [lng, lat] = centroid.geometry.coordinates;
      window.cityPolygonData.centroid = { lat, lng };
      window.cityPolygonData.areaKm2 = currentPolygonAreaKm2;

      console.log('Granular analysis disabled for city boundary');
    } else if (currentPolygonSource === 'draw' && drawnPolygonData) {
      drawnPolygonData.enableGranular = false;
      drawnPolygonData.gridSpacing = null;
      console.log('Granular analysis disabled for drawn polygon');
    } else {
      console.error('No polygon data found!');
      alert('Error: No polygon data found. Please try again.');
      return;
    }

    // Hide grid spacing modal and wait for it to fully hide
    const gridModal = bootstrap.Modal.getInstance(document.getElementById('gridSpacingModal'));
    if (gridModal) {
      // Listen for the modal hidden event
      const modalElement = document.getElementById('gridSpacingModal');
      modalElement.addEventListener('hidden.bs.modal', function onHidden() {
        // Remove the event listener to avoid duplicate calls
        modalElement.removeEventListener('hidden.bs.modal', onHidden);

        console.log('Grid modal fully hidden (skipped), showing asset modal...');

        // Show message
        showNotification('Granular analysis skipped. Centroid value will be used.', 'info');

        // Show polygon asset modal to continue with naming the asset
        let centroid = null;
        if (currentPolygonSource === 'city' && window.cityPolygonData) {
          centroid = window.cityPolygonData.centroid;
        } else if (currentPolygonSource === 'draw' && drawnPolygonData) {
          centroid = drawnPolygonData.centroid;
        }

        if (centroid) {
          console.log('Showing polygon asset modal with centroid:', centroid);
          showPolygonAssetModal(centroid.lat, centroid.lng);
        } else {
          console.error('No centroid found');
          alert('Error: Could not find polygon centroid. Please try again.');
        }
      }, { once: true });

      // Now hide the modal
      gridModal.hide();
    } else {
      console.error('Could not get grid modal instance');
    }
  }


// Make facilityMarkers accessible at window level
window.facilityMarkers = [];
window.facilityPolygons = [];

// Function to add a marker for a facility
function addFacilityMarker(facility) {
  // Create marker element
  const el = baseBlueCircle.cloneNode(true);
  
  // Create popup content for detailed sidebar
  let sidebarContent = `
    <h4><strong>${facility.Facility}</strong></h4>
    <p><strong>Coordinates:</strong> ${facility.Lat.toFixed(6)}, ${facility.Long.toFixed(6)}</p>
    ${facility.Archetype ? `<p><strong>Archetype:</strong> ${facility.Archetype}</p>` : ''}
    ${facility.geometry ? `<p><span class="badge bg-info">Polygon Asset</span></p>` : ''}
    <hr>
    <h5>Hazard Profile</h5>
    <div style="text-align: center; margin-bottom: 10px;">
      <ul style="list-style: none; padding: 0; margin: 0 auto; display: inline-block;">
        <li style="display: inline-block; margin-right: 15px; vertical-align: middle;">
          <span style="display: inline-block; width: 15px; height: 15px; background-color: green; margin-right: 8px;"></span>
          Low
        </li>
        <li style="display: inline-block; margin-right: 15px; vertical-align: middle;">
          <span style="display: inline-block; width: 15px; height: 15px; background-color: orange; margin-right: 8px;"></span>
          Medium
        </li>
        <li style="display: inline-block; vertical-align: middle;">
          <span style="display: inline-block; width: 15px; height: 15px; background-color: red; margin-right: 8px;"></span>
          High
        </li>
      </ul>
    </div>
  `;
  
  // Add hazard data if available
  if (facility.hasOwnProperty('Flood Depth (meters)')) {
    let floodClass = 'green';
    if (facility['Flood Depth (meters)'] === '0.5 to 1.5') floodClass = 'orange';
    if (facility['Flood Depth (meters)'] === 'Greater than 1.5') floodClass = 'red';
    
    sidebarContent += `
      <h5><strong>Flood</strong></h5>
      <p>
        <span style="display:inline-block; width:10px; height:10px; background-color: ${floodClass}; margin-right:5px;"></span>
        <strong>Flood Depth:</strong> ${facility['Flood Depth (meters)']}
      </p>
    `;
  }
  
  // Create hover popup with just the facility name
  const popup = new mapboxgl.Popup({
    closeButton: false,
    closeOnClick: false,
    offset: 25,
    className: 'facility-hover-popup'
  }).setHTML(`<strong>${facility.Facility}</strong>`);
  
  // Create marker with hover popup
  const marker = new mapboxgl.Marker({ element: el })
    .setLngLat([facility.Long, facility.Lat])
    .setPopup(popup)
    .addTo(multiHazardMap);
  
  // Add mouseenter event to show popup on hover
  marker.getElement().addEventListener('mouseenter', () => {
    marker.togglePopup();
  });
  
  // Add mouseleave event to hide popup
  marker.getElement().addEventListener('mouseleave', () => {
    marker.togglePopup();
  });
  
  // Add click handler to show detailed info in sidebar
  marker.getElement().addEventListener('click', () => {
    openSidebar(sidebarContent);
  });
  
  // Track markers
  window.facilityMarkers.push(marker);

  // Add polygon display if geometry is provided
  if (facility.geometry) {
    const sourceId = `facility-poly-${window.facilityPolygons.length}`;
    multiHazardMap.addSource(sourceId, {
      type: 'geojson',
      data: {
        type: 'Feature',
        geometry: facility.geometry
      }
    });

    multiHazardMap.addLayer({
      id: `${sourceId}-fill`,
      type: 'fill',
      source: sourceId,
      paint: {
        'fill-color': '#088',
        'fill-opacity': 0.4
      }
    });

    multiHazardMap.addLayer({
      id: `${sourceId}-outline`,
      type: 'line',
      source: sourceId,
      paint: {
        'line-color': '#000',
        'line-width': 2
      }
    });

    window.facilityPolygons.push(sourceId);
  }
  
  // Update proceed button visibility whenever markers are added
  if (typeof updateProceedButtonVisibility === 'function') {
    updateProceedButtonVisibility();
  }
  
  return marker;
}

// Clear all facility markers
function clearFacilityMarkers() {
  window.facilityMarkers.forEach(marker => marker.remove());
  window.facilityMarkers = [];
  window.facilityPolygons.forEach(id => {
    if (multiHazardMap.getLayer(`${id}-fill`)) {
      multiHazardMap.removeLayer(`${id}-fill`);
    }
    if (multiHazardMap.getLayer(`${id}-outline`)) {
      multiHazardMap.removeLayer(`${id}-outline`);
    }
    if (multiHazardMap.getSource(id)) {
      multiHazardMap.removeSource(id);
    }
  });
  window.facilityPolygons = [];
  
  // Update proceed button visibility whenever markers are cleared
  if (typeof updateProceedButtonVisibility === 'function') {
    updateProceedButtonVisibility();
  }
}

// Load facility data from session
function loadFacilityData() {
  console.log("Loading facility data...");
  
  // Show map loading indicator
  const loadingDiv = document.createElement('div');
  loadingDiv.id = 'map-loading';
  loadingDiv.style.position = 'absolute';
  loadingDiv.style.top = '50%';
  loadingDiv.style.left = '50%';
  loadingDiv.style.transform = 'translate(-50%, -50%)';
  loadingDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
  loadingDiv.style.color = 'white';
  loadingDiv.style.padding = '15px 20px';
  loadingDiv.style.borderRadius = '5px';
  loadingDiv.style.zIndex = '1000';
  loadingDiv.innerHTML = `
    <div style="display: flex; flex-direction: column; align-items: center;">
      <div style="margin-bottom: 10px;">
        <div style="border: 3px solid #f3f3f3; border-radius: 50%; border-top: 3px solid #ffcc00; width: 25px; height: 25px; animation: spin 1s linear infinite;"></div>
      </div>
      <div>Loading map data...</div>
    </div>
  `;
  
  document.getElementById('climate-hazard-map').appendChild(loadingDiv);
  
  fetch('/climate-hazards-analysis-v2/api/facility-data/')
    .then(response => response.json())
    .then(data => {
      console.log("Received facility data:", data);
      
      // Clear existing markers
      clearFacilityMarkers();
      
      // Add new markers
      if (data.facilities && data.facilities.length > 0) {
        console.log(`Adding ${data.facilities.length} markers to map`);
        data.facilities.forEach(facility => {
          addFacilityMarker(facility);
        });
        
        // Zoom to fit all markers
        fitMapToMarkers();
        
        // Update progress steps if the function exists
        if (typeof updateProgressSteps === 'function') {
          updateProgressSteps();
        }
        
        // Update proceed button visibility if the function exists
        if (typeof updateProceedButtonVisibility === 'function') {
          updateProceedButtonVisibility();
        }
      } else {
        console.log("No facilities found in data");
      }
      
      // Remove loading indicator
      const loadingElement = document.getElementById('map-loading');
      if (loadingElement) {
        loadingElement.remove();
      }
      
      // Remove loading overlay
      const loadingOverlay = document.getElementById('loading-overlay');
      if (loadingOverlay) {
        loadingOverlay.style.display = 'none';
      }
    })
    .catch(error => {
      console.error('Error loading facility data:', error);
      
      // Clear existing markers on error
      clearFacilityMarkers();
      
      // Remove loading indicator
      const loadingElement = document.getElementById('map-loading');
      if (loadingElement) {
        loadingElement.remove();
      }
      
      // Remove loading overlay
      const loadingOverlay = document.getElementById('loading-overlay');
      if (loadingOverlay) {
        loadingOverlay.style.display = 'none';
      }
      
      // Show error message on map
      const errorDiv = document.createElement('div');
      errorDiv.style.position = 'absolute';
      errorDiv.style.top = '50%';
      errorDiv.style.left = '50%';
      errorDiv.style.transform = 'translate(-50%, -50%)';
      errorDiv.style.backgroundColor = 'rgba(220, 53, 69, 0.8)';
      errorDiv.style.color = 'white';
      errorDiv.style.padding = '15px 20px';
      errorDiv.style.borderRadius = '5px';
      errorDiv.style.zIndex = '1000';
      errorDiv.style.maxWidth = '80%';
      errorDiv.style.textAlign = 'center';
      errorDiv.innerHTML = `
        <div>
          <div style="font-weight: bold; margin-bottom: 5px;">Error Loading Data</div>
          <div>${error.message || 'Failed to load facility data'}</div>
        </div>
      `;
      document.getElementById('climate-hazard-map').appendChild(errorDiv);
      
      // Auto-remove error after 5 seconds
      setTimeout(() => {
        errorDiv.remove();
      }, 5000);
    });
}

  function fitMapToMarkers() {
  const markers = window.facilityMarkers || [];
  if (markers.length === 0) return;

  const bounds = new mapboxgl.LngLatBounds();
  markers.forEach(marker => bounds.extend(marker.getLngLat()));
  multiHazardMap.fitBounds(bounds, { padding: 50, maxZoom: 15 });
}

  // Handle geocoder result - fetch city boundaries
  async function handleGeocoderResult(e) {
    const result = e.result;
    console.log('Geocoder result:', result);

    // Extract place name and coordinates
    const placeName = result.place_name || result.text;
    const [lng, lat] = result.center;

    // Show loading message
    showNotification('Fetching city boundaries...', 'info');

    try {
      // Fetch boundary from Nominatim (OpenStreetMap)
      const response = await fetch(
        `https://nominatim.openstreetmap.org/search?` +
        `q=${encodeURIComponent(placeName)}` +
        `&format=geojson` +
        `&polygon_geojson=1` +
        `&limit=1`,
        {
          headers: {
            'User-Agent': 'CLIMATE-Build-App'
          }
        }
      );

      if (!response.ok) throw new Error('Failed to fetch boundary');

      const data = await response.json();

      if (data.features && data.features.length > 0) {
        const feature = data.features[0];

        // Check if boundary geometry exists
        if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
          displayCityBoundary(feature.geometry, placeName);
          showNotification(`Boundary found for ${placeName}!`, 'success');
        } else {
          showNotification(`No boundary polygon found for ${placeName}. Try a more specific search.`, 'warning');
        }
      } else {
        showNotification(`No boundary found for ${placeName}. Try a more specific search.`, 'warning');
      }
    } catch (error) {
      console.error('Error fetching boundary:', error);
      showNotification('Error fetching city boundary. Please try again.', 'error');
    }
  }

  // Display city boundary on map
  function displayCityBoundary(geometry, name) {
    // Remove existing boundary if any
    removeCityBoundary();

    // Generate unique layer ID
    cityBoundaryLayerId = `city-boundary-${Date.now()}`;

    // Store boundary data
    currentCityBoundary = {
      name: name,
      geometry: geometry,
      geojson: {
        type: 'Feature',
        properties: { name: name },
        geometry: geometry
      }
    };

    // Add source
    multiHazardMap.addSource(cityBoundaryLayerId, {
      type: 'geojson',
      data: currentCityBoundary.geojson
    });

    // Add fill layer
    multiHazardMap.addLayer({
      id: `${cityBoundaryLayerId}-fill`,
      type: 'fill',
      source: cityBoundaryLayerId,
      paint: {
        'fill-color': '#FFA500',
        'fill-opacity': 0.3
      }
    });

    // Add outline layer
    multiHazardMap.addLayer({
      id: `${cityBoundaryLayerId}-outline`,
      type: 'line',
      source: cityBoundaryLayerId,
      paint: {
        'line-color': '#FF8C00',
        'line-width': 3
      }
    });

    // Fit map to boundary
    const bbox = turf.bbox(currentCityBoundary.geojson);
    multiHazardMap.fitBounds(bbox, { padding: 50 });

    // Show save button
    document.getElementById('save-boundary-btn').style.display = 'inline-block';
  }

  // Remove city boundary from map
  function removeCityBoundary() {
    if (cityBoundaryLayerId) {
      if (multiHazardMap.getLayer(`${cityBoundaryLayerId}-fill`)) {
        multiHazardMap.removeLayer(`${cityBoundaryLayerId}-fill`);
      }
      if (multiHazardMap.getLayer(`${cityBoundaryLayerId}-outline`)) {
        multiHazardMap.removeLayer(`${cityBoundaryLayerId}-outline`);
      }
      if (multiHazardMap.getSource(cityBoundaryLayerId)) {
        multiHazardMap.removeSource(cityBoundaryLayerId);
      }
      cityBoundaryLayerId = null;
    }
    currentCityBoundary = null;
    document.getElementById('save-boundary-btn').style.display = 'none';
  }

  // Save city boundary as asset
  async function saveBoundaryAsAsset() {
    if (!currentCityBoundary) {
      alert('No boundary to save. Please search for a city first.');
      return;
    }

    // Calculate centroid
    const centroid = turf.centroid(currentCityBoundary.geojson);
    const [lng, lat] = centroid.geometry.coordinates;

    // Calculate polygon area in km²
    const areaM2 = turf.area(currentCityBoundary.geojson); // Turf returns area in square meters
    const areaKm2 = areaM2 / 1000000;  // Convert to km²

    console.log(`City boundary area: ${areaKm2.toFixed(2)} km²`);

    // Check if polygon area qualifies for granular analysis (≥ 6 km²)
    if (areaKm2 >= 6) {
      console.log('City boundary qualifies for granular analysis - showing grid spacing modal first');
      // Show grid spacing modal FIRST with 'city' source, naming modal will come after
      showGridSpacingModal(currentCityBoundary.name, currentCityBoundary.geometry, areaKm2, 'city');
    } else {
      console.log('City boundary does not qualify for granular analysis - showing naming modal directly');
      // Show naming modal directly for small polygons
      showPolygonAssetModal(lat, lng);
      // Set the source so confirmPolygonAsset knows where to get the data
      currentPolygonSource = 'city';

      // Create temporary polygon data for small city boundaries
      if (!window.cityPolygonData) {
        window.cityPolygonData = {};
      }
      window.cityPolygonData.centroid = { lat, lng };
      window.cityPolygonData.geometry = currentCityBoundary.geometry;
      window.cityPolygonData.areaKm2 = areaKm2;
      window.cityPolygonData.enableGranular = false;
      window.cityPolygonData.gridSpacing = null;
    }
  }

  // Export boundaries as shapefile
  function exportShapefile() {
    showNotification('Preparing shapefile export...', 'info');

    // Call backend endpoint
    window.location.href = '/climate-hazards-analysis-v2/api/export-shapefile/';
  }

  // Show notification helper
  function showNotification(message, type = 'info') {
    // Remove existing notification if any
    const existing = document.getElementById('map-notification');
    if (existing) existing.remove();

    // Create notification element
    const notification = document.createElement('div');
    notification.id = 'map-notification';
    notification.style.position = 'absolute';
    notification.style.top = '60px';
    notification.style.right = '10px';
    notification.style.zIndex = '1000';
    notification.style.padding = '12px 20px';
    notification.style.borderRadius = '5px';
    notification.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
    notification.style.fontSize = '14px';
    notification.style.fontWeight = '500';
    notification.style.maxWidth = '300px';
    notification.style.animation = 'slideInRight 0.3s ease';

    // Set colors based on type
    const colors = {
      success: { bg: '#28a745', text: '#fff' },
      error: { bg: '#dc3545', text: '#fff' },
      warning: { bg: '#ffc107', text: '#000' },
      info: { bg: '#17a2b8', text: '#fff' }
    };

    const color = colors[type] || colors.info;
    notification.style.backgroundColor = color.bg;
    notification.style.color = color.text;
    notification.textContent = message;

    document.getElementById('climate-hazard-map').appendChild(notification);

    // Auto-remove after 4 seconds
    setTimeout(() => {
      notification.style.animation = 'slideOutRight 0.3s ease';
      setTimeout(() => notification.remove(), 300);
    }, 4000);
  }

  // Helper function to get CSRF token
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }

// Auto-init if the container exists on this page
  if (document.readyState !== 'loading') {
    if (document.getElementById('climate-hazard-map')) initializeMultiHazardMap();
  } else {
    document.addEventListener('DOMContentLoaded', () => {
      if (document.getElementById('climate-hazard-map')) initializeMultiHazardMap();
    });
  }
  

</script>